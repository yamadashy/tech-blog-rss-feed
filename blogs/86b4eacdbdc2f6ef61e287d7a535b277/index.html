<!doctype html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="author" content="yamadashy"><meta name="robots" content="index, follow"><meta property="og:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta property="og:title" content="開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS"><meta property="og:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta property="og:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta property="og:type" content="website"><meta property="og:site_name" content="企業テックブログRSS"><meta property="og:locale" content="ja_JP"><meta name="twitter:card" content="summary"><meta property="twitter:domain" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta 
property="twitter:url" content="https://yamadashy.github.io/tech-blog-rss-feed/"><meta name="twitter:title" content="開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS"><meta name="twitter:description" content="企業のテックブログの更新をまとめたRSSフィードを配信しています。記事を読んでその企業の技術・カルチャーを知れることや、質の高い技術情報を得られることを目的としています。"><meta name="twitter:image" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><meta name="thumbnail" content="https://yamadashy.github.io/tech-blog-rss-feed/images/og-image.png"><link rel="preload" href="../../styles/bundle.css" as="style"><meta name="google-site-verification" content="GPLvXv8kYtLMW912ZS54DKFEZL6ruOrjOFLdHVTo37o"><link rel="shortcut icon" href="../../images/favicon.ico"><link rel="apple-touch-icon" href="../../images/apple-icon.png"><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="../../feeds/atom.xml"><link rel="alternate" type="application/rss+xml" title="RSS2.0" href="../../feeds/rss.xml"><link rel="alternate" 
type="application/json" href="../../feeds/feed.json"><link rel="stylesheet" type="text/css" href="../../styles/bundle.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CNNNTL0NB3"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-CNNNTL0NB3")</script><title>開発ブログ｜株式会社Nextat（ネクスタット）のフィード｜企業テックブログRSS</title></head><body><header role="banner" class="ui-section-header"><div class="ui-layout-container"><div class="ui-section-header__layout ui-layout-flex"><a href="https://yamadashy.github.io/tech-blog-rss-feed/" role="link" aria-label="#"><img src="../../images/icon.png" alt="サイトロゴ" loading="eager" width="96" height="96"> <span class="ui-section-header__title">企業テックブログRSS</span></a><div class="ui-section-header__links"><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" target="_blank"><img src="../../images/icon-github.png" alt="GitHubロゴ" 
loading="eager" width="96" height="96"> </a><a href="https://x.com/yamadashy" role="link" aria-label="#" target="_blank"><img src="../../images/icon-x.png" alt="Xロゴ" loading="eager" width="96" height="96"></a></div></div></div></header><main role="main"><nav class="ui-nav"><div class="ui-layout-container"><div class="ui-section-nav__layout ui-layout-flex"><a class="ui-section-nav__link" href="../../">フィード</a> <a class="ui-section-nav__link" href="../../hot/">人気フィード</a> <a class="ui-section-nav__link" href="../../blogs/">ブログ一覧</a></div></div></nav><section class="ui-section-content ui-section-feed"><div class="ui-layout-container"><h2 class="ui-typography-heading">開発ブログ｜株式会社Nextat（ネクスタット）</h2><div class="ui-container-blog-summary"><div class="ui-blog-summary"><a class="ui-blog-summary__link" href="https://nextat.co.jp/">https://nextat.co.jp/</a><p class="ui-blog-summary__description">
京都を中心にシステム開発・Webサイト・ホームページ制作を行なっているシステム開発・Web制作会社Nextat（ネクスタット）の公式サイトです。Webサイトの開発から業務支援システムの開発まで幅広く手がけています。ホームページ製作は、SEOやCMS、更新・運用など、お客様に合わせた最適なサービスをご提案します。</p></div></div><h3 class="ui-typography-heading">フィード</h3><div class="ui-section-content--feature ui-layout-grid ui-layout-grid-3 ui-container-feed ui-container-feed--no-image"><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/394"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/394">CodexのSkillsを使って、プロンプト運用を効率化する</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、たっきーです。Nextat でも Codex などのAIエージェントを本格的に業務へ取り入れていこう、という動きが進んでいます。実装レビューの指示で毎回ほぼ同じことを書いている設計レビューの観点をコピペして投げているテストケースを書いてほしい時に、正常系・異常系・境界値の説明をしている毎回同じプロンプトを書くの、正直もったいないですよね。こうした “繰り返し発生する指示” は、実は Skills を使うと自動化できます。Skillsって何？https://github.com/openai/codex/blob/main/docs/skills.mdSkills をひとことで言うと...「特定のタスクを実行するための、専門知識を持たせる仕組み」です。簡単に特徴を挙げると...~/.codex/skills/&lt;skill-name&gt;/SKILL.md にファイルを作成するだけで、自動で読み込まれる常時読み込まれるのはメタデータのみ本文は Codex が必要なときだけ参照されるSkillsの書き方~/.codex/skills/&lt;skill-name&gt;/SKILL.md--- name: skill-name description: スキルの説明（いつ・何のために使うか） --- # 本文 name / description までは「Codexに読んでもらうメタ情報」を、本文は「ふだんプロンプトで書いていた内容」をそのまま書くイメージです。Skills の特徴メタデータだけ常時読み込み、本文は Codex が“必要なときに自動で選択”する今回の記事で一番伝えたい重要ポイントです。Codex が起動時に保持するのは、markdownファイルのうちnamedescriptionこれらの メタデータのみ です。そして本文は、メタデータからCodex 自身がタスク内容を判断し、「このスキルが必要だな」と思ったときだけに参照します。だから Skills は...コンテキストを圧迫しないユーザーによる明示的な呼び出しが不要という性質を持ちます。カスタムコマンドとの違いここは誤解されがちな部分ですが、非常に重要です。カスタムコマンドでも “共通化” はできます。/prompts:review/prompts:summary/prompts:lint-docなど、共通で
</div><div class="ui-feed-item__date" title="2025-12-10 06:00:00">17日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/393"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/393">Codex CLIのカスタムコマンドを使って業務を効率化する</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、前田です！カスタムコマンドを定義することで、日々の作業効率を大きく改善できるのが魅力です。 Codex CLI の「カスタムコマンド」機能の設定方法と、実際の使用例を紹介します！カスタムコマンドとは？コマンドに「役割」や「命令」を事前登録できる毎回プロンプトを入力しなくても、AIに同じ指示を与えられる ~/.codex/prompts/xxx.md のような Markdown ファイルで管理できます。簡単な挨拶を返す共通で使える「挨拶を返すコマンド」を作ってみます。設定ファイル（ ~/.codex/prompts/greet.md ）---使い方&gt; /prompts:greetお名前を教えてください。短い挨拶文をお返しします。&gt; 前田前田さん、こんにちは！お会いできてうれしいです。コードレビューをする長い指示を何度も繰り返し使用する時です。このPRの差分を取得し、レビューをしてください。そこで、この指示をカスタムコマンドとして事前に用意し、すぐに使えるようにしましょう！設定ファイル（ ~/.codex/prompts/review.md ）---※ 上記は架空のプロジェクト例のため、皆さんの環境・プロジェクトに合わせて設定ファイルを調整してください。&gt; /prompts:review PR_URL=&quot;https://github.com/XXX/pull/128&quot;おわりに長文タスクの要約や繰り返し作業の共通化など、さまざまな業務効率化に活用できます。参考文献：Codex CLI公式ドキュメント - Create your own slash commands with custom promptshttps://developers.openai.com/codex/guides/slash-commands/#create-your-own-slash-commands-with-custom-promptsCodex CLIのカスタムコマンドを完全攻略！よく使う指示を瞬時に呼び出す方法（Qiita - 著：とまだ氏）https://qiita.com/tomada/items/37d260807c4324c9898d</div><div class="ui-feed-item__date" 
title="2025-12-09 06:00:00">18日前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/392"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/392">AIに複雑なタスクを任せるときに必要なのは、“認識合わせ”</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、ヨシムラです。時間をかけたのに成果物がイメージと違う修正を依頼したら、さらに方向がずれてしまうどうも待ち時間が長い割に期待通りにならないと感じることは多いと思います。実はこれは、AI特有の問題ではなく、人にタスクを渡すときにも普通に起こりうる現象です。これはAIも同じです。なぜズレが発生するのかAIに複雑なタスクを投げたとき、出力に時間がかかる完成物の方向性がズレる修正しても修正してもズレが埋まらないという状態は、ほとんどが与えている文脈やスコープが曖昧なことが原因です。AIは、与えられた情報の中から最も“ありえそう”と思われる推論を行います。つまり、ズレは “AIの能力不足” というより、前提条件が合っていないことによる自然な結果として起きています。認識を揃えることで、AIは安定して動くAIが本来持っている性能を発揮させるには、タスクの最初の段階で認識を合わせることが重要です。特に効果が高いのは以下のポイントです。最初にプラン（計画）を出してもらう「まず、このタスクをどう進めるべきかプランを作って」過去の成果物やパターンを参照する「◯◯と同じ構成で作れそう？修正の影響範囲を先に確認する「◯◯を修正した場合、どの部分に影響がある？」自分の認識を言語化して確認する「このタスクは ×× のインターフェイスを実装する方針で考えている。こうした小さな認識合わせは、そのまま依頼者自身の理解のチェックにもなるため、複雑なタスクで特に効果的です。スコープを明確にすると、AIは無駄な推論をしない「このファイルだけを修正してほしい」といった具合に範囲を制限すると、AIが余計な推論にリソースを使わず、結果のブレも減ります。結局、AIの精度は“伝え方”で決まるAIが期待通りの成果物を返せないとき、与えている文脈が足りないだけというケースが多くあります。タスクに入る前に少し時間を使って、背景文脈ゴールスコープを整理して伝えるだけで、AIは安定して、意図通りに動いてくれます。AIは「なんでも自動でやってくれる存在」ではなく、前提が十分に揃ったときに最大のパフォーマンスを出す相棒です。認識合わせのプロセスを自然に取り入れながら、人とAIでより良い成果をつくっていけるチームを目指していきましょう。</div><div class="ui-feed-item__date" 
title="2025-11-27 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/391"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/391">Codex CLIを安全に使おう ~ sandboxモードの活用 ~</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、たけちゃんです。業務でCodex CLIを使用しており、コードや機密情報の流出防止には細心の注意を払っています。https://developers.openai.com/codex/security/#agent-sandboxsandboxモードとは sandboxモードの種類と効果ファイルアクセスに対する制限種類概要ユースケースread-onlyすべてのファイル操作が読み取り専用。編集や生成を伴う指示は一切実行できず、閲覧や調査に限定される。外部破壊リスクを完全に排除したい検証環境や、構成確認のみ行いたい場合。workspace-writeカレントディレクトリと許可されたwritable_roots配下のみ書き込み可。それ以外は読み取りに留め、変更には追加承認が必要。一般的な開発タスク。プロジェクト配下での修正は自由だが、システム領域や別プロジェクトへのアクセスを防ぐ。danger-full-access制限なし。任意パスへの読み書き、ツール実行も可能で、通常のシェルと同等に振る舞う。高度な自動化や統合テストなどサンドボックスが邪魔になる場面。誤操作リスクが最も高いため、CI用途や信頼済み環境のみで利用。ネットワークアクセスに対する制限 Approval Policy・ untrusted: 読み取り以外のほとんどのコマンドが都度承認待ちになる。新しいプラグインやスクリプトの安全性確認で有効。sandboxモードの使い方codexコマンドのオプションとして使うcodex --sandbox &lt;ファイルアクセスのモード&gt; --ask-for-approval &lt;Approval Policy&gt;codex --sandbox read-only --ask-for-approval untrustedとなります。config.tomlに記載する# config.tomlapproval_policy = &quot;untrusted&quot;sandbox_mode = &quot;read-only&quot;# config.toml[sandbox_workspace_write]network_access = true使用例では実際にread-only モードで起動してフォルダの削除を指示した場合どうなるかやってみましょう。codex --sandbox read-onlyho
</div><div class="ui-feed-item__date" title="2025-11-24 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/390"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/390">AGENTS.mdの肥大化を解消したい。Codex で「役割」を擬似的に切り替えてみる</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
はじめに：AGENTS.mdが「秘伝のタレ」化していませんか？問題点（人間側）：肥大化したAGENTS.mdは、可読性が悪く、人間がメンテナンスするのが困難（人間側）：AGENTS.mdをチームで共有する場合、巨大なAGENTS.mdファイル全体をレビューしなければならず、差分が分かりにくくなる（AI側）：バックエンド開発者に「フロントエンドのルール」まで読み込ませるのは非効率であり、コンテキストの「ノイズ」となって回答精度を低下させる理想：AIにも「専門分野」を持たせたいClaude Codeのサブエージェント機能です。GitHub Issue #2604）。そこで、Codex CLIの既存機能（カスタムプロンプト）を活用し、この機能を「擬似的に」実装しようと考えました。実装ステップ1：役割（コンテキスト）の物理的な分割プロジェクト内の myproject/.codex/agents/配下に配置します。ディレクトリ構成例：myproject/ &lt;-- プロジェクトルート├── AGENTS.md # 共通ルールファイル├── .codex/│ └── agents/│ ├── backend.md # バックエンドエンジニアの固有ルール│ ├── frontend.md # フロントエンドエンジニアの固有ルール│ ├── designer.md # 設計作成担当の固有ルール│ └── reviewer.md # コードレビュワーの固有ルール└── ...なぜプロジェクト配下なのか？Gitによるチーム共有: これらのAIルールファイルはプロジェクトのソースコードやドキュメントの一部となり、Gitでバージョン管理され、チームメンバー全員に自動で共有されます。コンテキストのローカル性: 特定のプロジェクトに特化したルールを、他のプロジェクトの設定と分離し、独立して管理できます。メンテナンスの容易性: AGENTS.md全体をレビューする必要がなく、変更があった役割ファイル（例: backend.md）だけをレビューすれば済むため、差分が明確になります。myproject/.codex/agents/配下のファイルは以下のような役割ごとのルール（指示）を書きます。myproject/.codex/agents/backend.md の内容例# 役割プロファイル: 熟練のバ
</div><div class="ui-feed-item__date" title="2025-11-19 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/389"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/389">Codex で Serena を使うためのセットアップ＆コンテキスト削減の調査レポ</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
はじめにお久しぶりです。しゅんちゃんです。寒くなってきましたね。Nextat AI活用ブログ記事シリーズとして Serena について書いてみます。TL;DRSerena は LSPを使用してコードを構造的に理解し、LLM/コーディングエージェントに「ファイル全体の読み込み・grep 検索」以外の選択肢を提供する MCP サーバーです。横断的なシンボル探索や依存追跡に強く、タスクによってはコンテキスト使用量の削減が見込めます。LLMのテキスト操作の限界LLM/コーディングエージェントは、コードを単なるテキストファイルとして扱います。結果として...ファイル全体を読み込んだり、grep/置換したりするため、処理時間とコンテキスト使用量が増えやすい宣言と参照の関係を踏まえずに置換するので、誤編集する可能性がある型やシンボルの関係が見えないため、大規模になるほどコードベースの俯瞰が難しくなるここを補うのが Serena の役割です。Serenaの概要何者か：IDE のようにシンボルを抽出してリレーショナルに扱える、セマンティックコード検索・編集ツールを LLM に提供するオープンソースの MCP サーバー仕組み：各言語のLSP（Language Server Protocol）を使用して定義・参照・型情報などを取得して、シンボル単位の操作を可能にしている。対応言語（弊社主要言語のみを抜粋）Go（gopls のインストールが必要）JavaScript / TypeScriptPythonPHP（LSP として Intelephense を使用している。プレミアム機能を使用するには環境変数を設定する必要がある）Markdown（プロジェクト設定を生成するときに明示的に --language markdown を指定する必要がある。ドキュメントの多いプロジェクトで有効）利用先：Claude Code/Desktop、Codex、Gemini-CLI、VSCode/Cursor/IntelliJ、Cline/RooCode、OpenWebUI、Jan、Agno などのクライアントから MCP として利用可能セットアップ（Codex連携）Codex：v0.57.0Serena：v0.1.4uv：v0.8.17uvのインストールhttps://docs.astral.sh/uv/ge
</div><div class="ui-feed-item__date" title="2025-11-17 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/387"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/387">[difit] AIが書いたコードをGitHubのPull Request風の画面でレビューし、AIに修正させる</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
こんにちは、カミオです。検証環境Node.js 23.11.0difit 2.2.3difitとは差分とコメントを組み合わせたAIエージェント用プロンプトを簡単にクリップボードにコピーすることもでき、AIとの連携が念頭に置かれているツールです。https://github.com/yoshiko-pg/difit使い方npx difitREADMEをご確認ください。npx difit . # すべての未コミット差分（ステージングエリア + 未ステージ）npx difit staged # ステージングエリアの差分npx difit working # 未ステージ差分のみレビューするsrc/Application.php:L67255文字にして=====src/Application.php:L73テストを追加して下記レビューの指摘事項を一つずつ修正してsrc/Application.php:L67255文字にして=====src/Application.php:L73テストを追加してnpx difit --cleanおわりにAIエージェントの活用により、コードを書くよりレビューすることの比率が高くなってきていますが、見慣れた画面でレビューできるだけでも気分がだいぶ楽になりますね。AIと連携させずとも、ローカルでGitHubとほぼ同じ画面で差分が確認できるので、Pushの前のセルフレビューとして利用するのもおすすめです。</div><div class="ui-feed-item__date" title="2025-11-14 06:00:00">1ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/388"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" 
href="https://nextat.co.jp/staff/archives/388">AIを活用してテストケースを書いてみる</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
皆さんお久しぶりです、かっちゃんです。 最近NextatではCodexを使用して開発の効率を上げていこう期間に入りまして、その一環で記事を書いています。テストケース ✖︎ AI で楽にテストを書こう今回、なぜテストケース ✖︎ AI という組み合わせにしたかというと、自分自身がテストケースを書くのが苦手だからです。笑めっちゃ細かいところまで書かないとダメだし、いろんなパターンのケースを考えないといけないし、思考量も書く量も非常に多くて大変です。そこで文章理解と、思考をまとめるのが得意な AIに嫌な部分を担ってもらおう ということです。大前提として、実装の元となる設計書が詳細に書かれていること。じゃないと今回の記事で紹介する手法の本領は発揮されません。BDDという開発手法を使うBDDとは Behavior-Driven Development（振る舞い駆動開発） の略で、ソフトウェア開発における開発手法の一つです。BDDは、既存のテスト駆動開発（TDD）を発展させたもので、テストを書く前に「何を作るべきか」の共通理解を深めることに重点を置いています。テストを書く前に「何を作るべきか」を深めるというところがポイントです。Gherkin（ガーキン）形式BDDでは「Gherkin（ガーキン）」と呼ばれる特定の形式の自然言語を使用して、テストケースを記述します。Gherkinは以下の3つのキーワードを中心に構成され、これを「シナリオ」または「ユーザーストーリー」と呼びます。キーワード役割意味Given (前提)システムの初期状態や環境を設定する。「〇〇が既に存在する状態のとき」When (事象/行動)ユーザーが行う行動や、システムに起こるイベント。「ユーザーが××という操作をしたとき」Then (結果)期待されるシステムの結果（振る舞い）。「システムは△△という結果を返すはずだ」【記述例】AIに設計を読ませてBDDを書いてもらうまず必要なのがAIに読み込ませるための設計と、BDDを作成してもらうためのルールです。AIへの指示（ルール）ECサイト クーポン適用機能 設計書（要約）今回は例として出しているので簡易的な設計になっています。項目概要機能概要注文時にクーポンコードを入力し、複数のビジネスルールに基づいたバリデーションと割引計算を行い、最終的な注文金額を確定する。処理フロ
</div><div class="ui-feed-item__date" title="2025-11-12 01:29:25">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/386"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/386">仕様駆動開発IDE KiroとEARS について調べてみた</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
はじめにこんにちは、ヨシです。今回は、Kiro に採用されている EARS という仕様の記法について気になったので調べてみました。 Kiro 自体は実務で利用してはいませんが、Kiro で採用されている考え方を理解することで最近流行っている仕様駆動開発の考え方を学べるとも思っています。Kiro とはAWSが開発している Kiro は AI エージェントを使った仕様駆動開発(spec driven development)を行うためのAI IDE (統合開発環境) です。Kiro には大きく2つの概念があります。それが spec と hook です。spec (仕様): アプリケーション開発における機能の開発プロセスを形式化する構造化された成果物hook (フック): イベントに応じて、開発者が見落としがちなことや、作業中にバックグラウンドで完了する定型的作業を自動的に行う機能Kiro はこの2つの概念を利用して、仕様駆動開発を行います。spec の基盤となる3つの主要ファイルKiro の spec によって、プロダクトの要件と技術的な実装詳細とのギャップを埋めることで、開発の反復的作業を削減することができるようになるとのことです。各仕様の基盤となるのは以下の3つの主要ファイルで、Kiro はインタラクティブにこれらを生成します。requirements.md : ユーザーストーリーと受け入れ基準を構造化されたEARS表記法で記述design.md : 技術アーキテクチャ、シーケンス図、実装上の考慮事項などtasks.md : 個別かつ追跡可能なタスクを含む詳細な実装計画例えば、プロジェクトで foo という機能を開発する際には以下のように spec として3つのファイルを後述のワークフローで段階的に定義し、これらのドキュメントを元にAIエージェントによる仕様駆動開発が行われます。ワークフロー具体的な開発のワークフローは、以下のような開発フェーズを段階的に行っていくというものになります。 これによって、次のステップに進む前に各ステップが適切に完了することを保証できるようになっています。要件フェーズ (Requirements Phase) requirements.md ファイルを作成/編集デザインフェーズ (Design Phase) design.md ファイルを
</div><div class="ui-feed-item__date" title="2025-11-06 01:55:46">2ヶ月前</div></div></div><div class="ui-feed-item"><a class="ui-feed-item__og-image" href="https://nextat.co.jp/staff/archives/385"><img src="../../images/alternate-feed-image.png" alt="記事のアイキャッチ画像" loading="lazy" width="256" height="256"></a><div class="ui-feed-item__content"><a class="ui-feed-item__title" href="https://nextat.co.jp/staff/archives/385">Codexによる並列開発を目指したディレクトリ構造の準備</a><div class="ui-feed-item__blog-title">開発ブログ｜株式会社Nextat（ネクスタット）</div><div class="ui-feed-item__summary">
はじめにお久しぶりです。ヨシです。AI活用ブログ記事シリーズの第三弾です。昨今、Codexなどの生成AIのCLIツールを利用した並列開発が流行っていますが、今回は並列開発に向けた準備として行っていることについて語りたいと思います。本格的な並列開発についてはとある事情からまだ行えていませんが、その準備として何をやっているかについて解説します。また、そのような流れからCLIやターミナル周りの仕組みを強化するモチベーションが湧いており、今回の記事では、私が行っているCodexを活用したプロジェクトのドキュメント運用についてまとめ、ディレクトリの分割思想やターミナルマルチプレクサ／lazygitとの連携などについても解説します。プロジェクトディレクトリの全体構造まず、プロジェクト全体のディレクトリ構造について語りたいと思います。現在私がアサインされているプロジェクトでは複数のリポジトリが存在しており、それらをまとめて一つのディレクトリに配置することにしています。以下のように、ルート直下に各リポジトリを包むラッパーディレクトリを配置し、その中ではgit worktreeで並列展開できるようにしています。.├── AGENTS.md # プロジェクト全体についてのAGENTS.md├── docs # ドキュメント専用リポジトリ├── proj-1-repos # 配下に同一のリポジトリのworktree展開 │ ├── proj-1-main│ ├── proj-1-sub│ └── proj-1-third├── proj-2-repos└── proj-3-reposこのような配置では以下のような目的のもとで運用を行っています。人間とCodexが同時に作業しても衝突しづらいよう、*-repos 配下に *-main と *-sub などを用意して必要分だけworktreeを増設できますルートから横並びの構造にしているため、tmuxやZellijでタブを切り替えるだけで関連リポジトリへ即アクセスできますそれでは、このディレクトリの運用についていくつかの観点で詳しく解説していきたいと思います。Codex生成ドキュメントの管理まず、Codexを使う上では特にドキュメントを多く生成させるようにしています。ソースコードの変更後に何をどのような目的で修正したかや、既存のコードベースの
</div><div class="ui-feed-item__date" title="2025-11-05 02:03:47">2ヶ月前</div></div></div></div></div></section></main><footer role="contentinfo" class="ui-section-footer"><div class="ui-layout-container"><div class="ui-layout-column-6 ui-layout-column-center"><div class="ui-component-cta ui-layout-flex ui-section-footer__site-info"><p class="ui-text-note">このサイトは<br>記事を読んでその企業の技術・カルチャーを知れることや<br>質の高い技術情報を得られることを目的としています。</p><p class="ui-text-note">追加したいブログがある場合は<br><a href="https://github.com/yamadashy/tech-blog-rss-feed#%E3%82%B5%E3%82%A4%E3%83%88%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95" target="_blank">サイトの追加方法</a> をご参照ください。</p></div></div></div><div class="ui-layout-container"><div class="ui-section-footer__layout ui-layout-flex"><p class="ui-section-footer--copyright ui-text-note"><a class="ui-text-note" href="https://github.com/yamadashy/" target="_blank"><small>@yamadashy</small></a></p><a href="https://github.com/yamadashy/tech-blog-rss-feed/" role="link" aria-label="#" 
class="ui-text-note" target="_blank"><small>GitHub</small></a></div></div></footer></body></html>